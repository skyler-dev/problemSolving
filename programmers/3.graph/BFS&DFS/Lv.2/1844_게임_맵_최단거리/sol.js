// https://school.programmers.co.kr/learn/courses/30/lessons/1844
/**
 * [문제 설명]
 * ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.
 * 지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.
 * (이미지)
 * 위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.
 * 아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.
 * (이미지)
 * * 첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다.
 * * 두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.
 * 위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.
 * 만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.
 * (이미지)
 * 게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.
 * [제한 사항]
 * * maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다.
 * * * n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다.
 * * maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다.
 * * 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.
 */

// 거리를 큐에 함께 넣는 버전

// 최단거리 -> BFS
// 큐에 "좌표와 거리" 넣기
// 방문체크용 배열 -> 각 좌표의 인덱스가 1부터 처리되도록 할 것
// 상하좌우 좌표이동 칸수 필요 -> 범위이내 체크
// 이동조건 : 좌표가 범위 이내이고, 해당 좌표값이 1이고, 방문한적 없을 때

// 도착좌표에 먼저 도달했을 때가 최단거리!!!!
// shift는 O(n)이지만 요소가 적을 경우에는 자바스크립트 엔진에서 최적화를 해준다.

function solution(maps) {
    const n = maps.length;
    const m = maps[0].length;
    const check = Array.from(Array(n+1), ()=>Array(m+1).fill(false));
    const dx = [-1, 1, 0, 0];
    const dy = [0, 0, -1, 1];
    const destX = n;
    const destY = m;
    
    // 지도의 각 좌표의 인덱스가 1부터 처리되도록
    const fixedMaps = [Array(m).fill(null), ...maps.map((row)=>[null, ...row])]
    
    // BFS
    const queue = [];
    // 각 `x좌표, y좌표, 거리`
    queue.push([1,1,1]);
    check[1][1] = true; // 시작좌표 방문처리
    // 빈 큐가 되면 종료
    while(queue.length > 0){
        const [x, y, distance] = queue.shift(); // 현재 좌표
        if(x === destX && y === destY) return distance; // 도착좌표 도달
        
        // 상하좌우 4방향 둘러보기
        for(let k = 0 ; k < 4 ; k++){
            const newX = x + dx[k];
            const newY = y + dy[k];
            const newD = distance + 1;
            if(
                newX >= 1 && newX <= n && 
                newY >= 1 && newY <= m &&
                fixedMaps[newX][newY] === 1 &&
                !check[newX][newY]
            ){
                
                queue.push([newX, newY, newD]);
                check[newX][newY] = true;
            }
        }
    }

    return -1; // 도착좌표 도달 불가 시
}

// 정확성  테스트
// 테스트 1 〉	통과 (0.29ms, 33.5MB)
// 테스트 2 〉	통과 (0.31ms, 33.5MB)
// 테스트 3 〉	통과 (0.48ms, 33.4MB)
// 테스트 4 〉	통과 (0.32ms, 33.5MB)
// 테스트 5 〉	통과 (0.33ms, 33.5MB)
// 테스트 6 〉	통과 (0.31ms, 33.4MB)
// 테스트 7 〉	통과 (0.35ms, 33.5MB)
// 테스트 8 〉	통과 (0.31ms, 33.5MB)
// 테스트 9 〉	통과 (0.31ms, 33.5MB)
// 테스트 10 〉	통과 (0.31ms, 33.5MB)
// 테스트 11 〉	통과 (0.31ms, 33.5MB)
// 테스트 12 〉	통과 (0.32ms, 33.5MB)
// 테스트 13 〉	통과 (0.31ms, 33.4MB)
// 테스트 14 〉	통과 (0.44ms, 33.4MB)
// 테스트 15 〉	통과 (0.29ms, 33.5MB)
// 테스트 16 〉	통과 (0.16ms, 33.4MB)
// 테스트 17 〉	통과 (0.31ms, 33.5MB)
// 테스트 18 〉	통과 (0.14ms, 33.5MB)
// 테스트 19 〉	통과 (0.14ms, 33.5MB)
// 테스트 20 〉	통과 (0.13ms, 33.4MB)
// 테스트 21 〉	통과 (0.15ms, 33.4MB)
// 효율성  테스트
// 테스트 1 〉	통과 (17.65ms, 38.7MB)
// 테스트 2 〉	통과 (20.14ms, 37.1MB)
// 테스트 3 〉	통과 (11.92ms, 37.7MB)
// 테스트 4 〉	통과 (16.03ms, 37.5MB)