// https://school.programmers.co.kr/learn/courses/30/lessons/67258
/**
 * [문제 설명]
 * 개발자 출신으로 세계 최고의 갑부가 된 어피치는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다.
 * 어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다.
 * 어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다.
 * 진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매
 * 예를 들어 아래 진열대는 4종류의 보석(RUBY, DIA, EMERALD, SAPPHIRE) 8개가 진열된 예시입니다.
 * | 진열대 번호 | 1   | 2    | 3    | 4   | 5   | 6       | 7        | 8   |
 * | 보석 이름   | DIA | RUBY | RUBY | DIA | DIA | EMERALD | SAPPHIRE | DIA |
 * 진열대의 3번부터 7번까지 5개의 보석을 구매하면 모든 종류의 보석을 적어도 하나 이상씩 포함하게 됩니다.
 * 진열대의 3, 4, 6, 7번의 보석만 구매하는 것은 중간에 특정 구간(5번)이 빠지게 되므로 어피치의 쇼핑 습관에 맞지 않습니다.
 * 진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요.
 * 가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 시작 진열대 번호가 가장 작은 구간을 return 합니다.
 * 
 * [제한사항]
 * gems 배열의 크기는 1 이상 100,000 이하입니다.
 * gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다.
 * gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다.
 * gems 배열의 각 원소는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다.
 */

// 투포인터
// 구간 찾기

// 필요한 것 : 포인터 2개, 반환할 것, 담아놓을 것, (타겟 / 비교할 것)

function solution(gems) {
    let start = 0;
    let end = 0;
    let result = [1, gems.length]; // 가장 긴 길이로 초기화. 인덱스와 1 차이남
    
    let gemKinds = new Set(gems).size; // 타겟
    let collect = new Map();
    
    // 미리 처리
    collect.set(gems[0], 1); // start 0, end 0일 때
    
    // 순회
    while(start < gems.length && end < gems.length){
        // 해당 구간에서 타겟(보석 종류)을 충족한다면,
        if(collect.size === gemKinds){
            // 더 작은 구간이라면 갱신 (같은 경우는, start가 가장 작은 구간을 선택하므로 무시)
            if(end - start < result[1] - result[0]){
                result = [start + 1, end + 1];
            }
            // 전 처리
            collect.set(gems[start], collect.get(gems[start]) - 1);
            if(collect.get(gems[start]) === 0){
                collect.delete(gems[start]);
            }
            start += 1;

        } else { // 충족하지 못한다면,
            end += 1;
            // 후 처리
            if(end < gems.length){
                collect.set(gems[end], (collect.get(gems[end]) || 0) + 1); // 옆에 있는 보석도 (존재하면) 담기
            }
        }
        // console.log('start', start, 'end', end)
        // console.log(collect)
    }
    return result;
}

// 정확성  테스트
// 테스트 1 〉	통과 (0.21ms, 33.7MB)
// 테스트 2 〉	통과 (0.21ms, 33.6MB)
// 테스트 3 〉	통과 (0.26ms, 33.5MB)
// 테스트 4 〉	통과 (0.43ms, 33.6MB)
// 테스트 5 〉	통과 (0.41ms, 33.6MB)
// 테스트 6 〉	통과 (0.08ms, 33.5MB)
// 테스트 7 〉	통과 (0.18ms, 33.5MB)
// 테스트 8 〉	통과 (0.37ms, 33.6MB)
// 테스트 9 〉	통과 (0.49ms, 33.7MB)
// 테스트 10 〉	통과 (0.40ms, 33.5MB)
// 테스트 11 〉	통과 (0.71ms, 33.5MB)
// 테스트 12 〉	통과 (0.99ms, 33.7MB)
// 테스트 13 〉	통과 (0.84ms, 33.6MB)
// 테스트 14 〉	통과 (0.73ms, 33.6MB)
// 테스트 15 〉	통과 (5.33ms, 37MB)
// 효율성  테스트
// 테스트 1 〉	통과 (4.70ms, 37.1MB)
// 테스트 2 〉	통과 (3.86ms, 37.3MB)
// 테스트 3 〉	통과 (5.54ms, 37.1MB)
// 테스트 4 〉	통과 (5.04ms, 38.9MB)
// 테스트 5 〉	통과 (8.18ms, 38.1MB)
// 테스트 6 〉	통과 (7.11ms, 38MB)
// 테스트 7 〉	통과 (7.77ms, 38.7MB)
// 테스트 8 〉	통과 (8.31ms, 38.9MB)
// 테스트 9 〉	통과 (8.35ms, 38.9MB)
// 테스트 10 〉	통과 (10.34ms, 39.2MB)
// 테스트 11 〉	통과 (12.26ms, 40.2MB)
// 테스트 12 〉	통과 (12.54ms, 41.9MB)
// 테스트 13 〉	통과 (16.02ms, 43.5MB)
// 테스트 14 〉	통과 (17.77ms, 39.4MB)
// 테스트 15 〉	통과 (17.15ms, 40.4MB)