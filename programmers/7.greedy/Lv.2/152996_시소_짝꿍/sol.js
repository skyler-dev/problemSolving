// https://school.programmers.co.kr/learn/courses/30/lessons/152996
/**
 * [문제 설명]
 * 어느 공원 놀이터에는 시소가 하나 설치되어 있습니다. 이 시소는 중심으로부터 2(m), 3(m), 4(m) 거리의 지점에 좌석이 하나씩 있습니다.
 * 이 시소를 두 명이 마주 보고 탄다고 할 때, 시소가 평형인 상태에서 각각에 의해 시소에 걸리는 토크의 크기가 서로 상쇄되어 완전한 균형을 이룰 수 있다면 그 두 사람을 시소 짝꿍이라고 합니다. 즉, 탑승한 사람의 무게와 시소 축과 좌석 간의 거리의 곱이 양쪽 다 같다면 시소 짝꿍이라고 할 수 있습니다.
 * 사람들의 몸무게 목록 weights이 주어질 때, 시소 짝꿍이 몇 쌍 존재하는지 구하여 return 하도록 solution 함수를 완성해주세요.
 * 
 * [제한 사항]
 * 2 ≤ weights의 길이 ≤ 100,000
 * 100 ≤ weights[i] ≤ 1,000
 * * 몸무게 단위는 N(뉴턴)으로 주어집니다.
 * * 몸무게는 모두 정수입니다.
 */

// 중복된 몸무게 존재 -> (50, 100A), (50, 100B)은 쌍이 2개임 -> 몸무게 당 사람 수 체크
// 작은 몸무게의 배수가 존재하는 지 확인필요 -> 몸무게 큰 사람 부터 처리
// 현재 사람 이외에, 짝꿍이 될 사람들을 찾고 카운트 해야함 -> 현재 몸부게를 기록하기 전에 순회먼저

// 현재 상황에서 기준에 따라 제일 합리적인 판단
// 기준 : 몸무게 큰 사람부터. 자기자신 제외한, 자기보다 몸무게 큰 사람들 중에서 짝꿍 찾기

function solution(weights) {
    const mapping = new Map(); // 몸무게 : 사람 수
    const pairsRatio = [1, 3/2, 2, 4/3]; // (같은 위치), (2 : 3), (2 : 4), (3 : 4)
    let cnt = 0;
    
    weights
        .sort((a, b) => b - a)
        .forEach((w)=>{
        // 짝궁이 될 사람들 순회
        for(const r of pairsRatio){
            if(mapping.has(w * r)) cnt += mapping.get(w * r);
        }
        // 현재 사람(자기 자신) 기록
        mapping.set(w, (mapping.get(w) ?? 0) + 1);
    })
    
    return cnt;
}

// 정확성  테스트
// 테스트 1 〉	통과 (0.09ms, 33.4MB)
// 테스트 2 〉	통과 (0.30ms, 33.4MB)
// 테스트 3 〉	통과 (0.25ms, 33.4MB)
// 테스트 4 〉	통과 (14.60ms, 37.6MB)
// 테스트 5 〉	통과 (18.78ms, 37.9MB)
// 테스트 6 〉	통과 (20.82ms, 38.8MB)
// 테스트 7 〉	통과 (26.73ms, 39MB)
// 테스트 8 〉	통과 (30.00ms, 41.7MB)
// 테스트 9 〉	통과 (57.94ms, 42.6MB)
// 테스트 10 〉	통과 (46.44ms, 43.5MB)
// 테스트 11 〉	통과 (69.93ms, 43.6MB)
// 테스트 12 〉	통과 (26.35ms, 43.1MB)
// 테스트 13 〉	통과 (33.49ms, 42.8MB)
// 테스트 14 〉	통과 (48.93ms, 42.9MB)
// 테스트 15 〉	통과 (37.77ms, 42.7MB)
// 테스트 16 〉	통과 (0.14ms, 33.4MB)
// 테스트 17 〉	통과 (0.12ms, 33.6MB)